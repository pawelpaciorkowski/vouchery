// Plik: backend-api/server.js - WERSJA FINALNA Z ZABEZPIECZENIEM TOKENAMI JWT i logowaniem debug

// --- INICJALIZACJA ---
require('dotenv').config({ path: require('path').resolve(__dirname, '.env') });
const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
const CryptoJS = require('crypto-js');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken'); // Biblioteka do token√≥w
const axios = require('axios'); // Do weryfikacji reCAPTCHA
const debug = require('debug');

// Inicjalizacja loger√≥w debug
const logServer = debug('app:server');
const logDb = debug('app:db');
const logError = debug('app:error');
const logAuth = debug('app:auth');
const logApi = debug('app:api');


const app = express();
const port = process.env.PORT || 3001;

logServer('Aplikacja startuje...');

// --- KLUCZE I KONFIGURACJA ---
const ENCRYPTION_KEY = process.env.FORM_ENCRYPTION_KEY;
const JWT_SECRET = process.env.JWT_SECRET; // Nowy sekret dla token√≥w
const RECAPTCHA_SECRET_KEY = process.env.RECAPTCHA_SECRET_KEY; // Klucz reCAPTCHA

if (!ENCRYPTION_KEY || !JWT_SECRET || !RECAPTCHA_SECRET_KEY) {
    logError("Krytyczny b≈ÇƒÖd: Brak kluczy w .env. Ko≈Ñczƒô pracƒô.");
    throw new Error("Klucze FORM_ENCRYPTION_KEY, JWT_SECRET i RECAPTCHA_SECRET_KEY muszƒÖ byƒá zdefiniowane w pliku .env");
}
logServer('Klucze konfiguracyjne wczytane pomy≈õlnie.');


const pool = mysql.createPool({
    host: process.env.DATABASE_HOST,
    user: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_NAME,
    port: process.env.DATABASE_PORT || 3306,
});
logDb('Pula po≈ÇƒÖcze≈Ñ z bazƒÖ danych utworzona.');


// --- MIDDLEWARES ---
app.use(express.json());
app.use(cors({
    origin: "*",
}));

// Middleware do logowania ka≈ºdego zapytania
app.use((req, res, next) => {
    logApi('Otrzymano zapytanie: %s %s', req.method, req.url);
    next();
});


// --- NOWY MIDDLEWARE DO WERYFIKACJI TOKENU ---
const authenticateToken = (req, res, next) => {
    logAuth('Pr√≥ba autoryzacji tokenu...');
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Oczekujemy formatu "Bearer TOKEN"

    if (token == null) {
        logAuth('Autoryzacja nieudana: Brak tokenu.');
        return res.status(401).json({ message: 'Brak autoryzacji - token nie zosta≈Ç dostarczony.' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            logAuth('Autoryzacja nieudana: Token nieprawid≈Çowy lub niewa≈ºny. B≈ÇƒÖd: %o', err);
            return res.status(403).json({ message: 'Brak dostƒôpu - token jest nieprawid≈Çowy lub niewa≈ºny.' });
        }
        req.user = user; // Zapisujemy dane z tokenu (np. id, rola) w obiekcie zapytania
        logAuth('Autoryzacja pomy≈õlna dla u≈ºytkownika: %o', user);
        next(); // Przechodzimy dalej
    });
};


// --- ENDPOINTY API ---

// Endpoint do zapisu formularza (publiczny, nie wymaga tokenu)
app.post('/api/forms', async (req, res) => {
    logApi('POST /api/forms - pr√≥ba zapisu nowego formularza.');

    try {
        const { recaptcha, ...formData } = req.body;

        // üîí --- WY≈ÅƒÑCZONA WALIDACJA RECAPTCHA (tryb testowy) ---
        logApi('üß™ TRYB TESTOWY: Pomijamy weryfikacjƒô reCAPTCHA.');

        /*
        // --- W≈ÅA≈öCIWA WALIDACJA (ZAKOMENTOWANA) ---
        if (!recaptcha) {
            logApi('Zapis formularza odrzucony: Brak tokenu reCAPTCHA.');
            return res.status(400).json({ message: 'Weryfikacja reCAPTCHA jest wymagana.' });
        }

        logApi('Weryfikacja reCAPTCHA...');
        const recaptchaRes = await axios.post(
            'https://www.google.com/recaptcha/api/siteverify',
            new URLSearchParams({
                secret: RECAPTCHA_SECRET_KEY,
                response: recaptcha
            }).toString(),
            {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }
        );

        if (!recaptchaRes.data.success) {
            logApi('Weryfikacja reCAPTCHA nie powiod≈Ça siƒô. Kody b≈Çƒôd√≥w: %o', recaptchaRes.data['error-codes']);
            return res.status(400).json({
                message: 'Weryfikacja reCAPTCHA nie powiod≈Ça siƒô.',
                'error-codes': recaptchaRes.data['error-codes'],
            });
        }

        logApi('Weryfikacja reCAPTCHA pomy≈õlna.');
        */

        // --- Szyfrowanie i zapis danych ---
        const encryptedData = CryptoJS.AES.encrypt(JSON.stringify(formData), ENCRYPTION_KEY).toString();
        logDb('Dane formularza zaszyfrowane.');

        const query = `INSERT INTO form_submissions (encrypted_data) VALUES (?)`;
        logDb('Wykonywanie zapytania do bazy: %s', query);
        const [result] = await pool.query(query, [encryptedData]);
        logDb('Formularz zapisany w bazie, ID: %s', result.insertId);

        res.status(201).json({ message: 'Formularz zapisany!', insertedId: result.insertId });
    } catch (error) {
        logError('B≈ÇƒÖd przy zapisie do bazy: %o', error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera' });
    }
});



// Endpoint logowania (publiczny, bo tutaj generujemy token)
app.post('/login', async (req, res) => {
    logAuth('Otrzymano zapytanie do /login. Cia≈Ço zapytania: %o', req.body);
    const { username, password } = req.body;
    logAuth('Pr√≥ba logowania dla u≈ºytkownika: %s', username);
    if (!username || !password) {
        logAuth('Logowanie odrzucone: Brak nazwy u≈ºytkownika lub has≈Ça.');
        return res.status(400).json({ message: 'Nazwa u≈ºytkownika i has≈Ço sƒÖ wymagane.' });
    }
    try {
        const query = 'SELECT * FROM users WHERE username = ?';
        logDb('Wykonywanie zapytania do bazy: %s', query);
        const [rows] = await pool.query(query, [username]);
        if (rows.length === 0) {
            logAuth('Logowanie nieudane: Nie znaleziono u≈ºytkownika %s', username);
            return res.status(401).json({ message: 'B≈Çƒôdne dane logowania.' });
        }

        const user = rows[0];
        const isMatch = await bcrypt.compare(password, user.password_hash);
        if (!isMatch) {
            logAuth('Logowanie nieudane: B≈Çƒôdne has≈Ço dla u≈ºytkownika %s', username);
            return res.status(401).json({ message: 'B≈Çƒôdne dane logowania.' });
        }

        const userPayload = { id: user.id, username: user.username, role: user.role };
        const accessToken = jwt.sign(userPayload, JWT_SECRET, { expiresIn: '1h' });
        logAuth('Logowanie pomy≈õlne. Wygenerowano token dla u≈ºytkownika: %o', userPayload);

        res.status(200).json({ message: 'Logowanie pomy≈õlne!', token: accessToken, role: user.role });
    } catch (error) {
        logError('B≈ÇƒÖd logowania: %o', error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera.' });
    }
});


// --- ENDPOINTY CHRONIONE (wymagajƒÖ tokenu) ---

app.get('/api/forms', authenticateToken, async (req, res) => {
    logApi('GET /api/forms - pobieranie wszystkich zg≈Çosze≈Ñ (chronione).');
    try {
        // Pobieramy tylko ID, zaszyfrowane dane i datƒô
        const query = 'SELECT id, encrypted_data, created_at FROM form_submissions ORDER BY created_at DESC';
        logDb('Wykonywanie zapytania do bazy: %s', query);
        const [rows] = await pool.query(query);
        logDb('Pobrano %d zg≈Çosze≈Ñ z bazy.', rows.length);
        res.status(200).json(rows);
    } catch (error) {
        logError('B≈ÇƒÖd przy pobieraniu danych: %o', error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera' });
    }
});

// Pobieranie listy u≈ºytkownik√≥w - teraz wymaga tokenu
app.get('/api/users', authenticateToken, async (req, res) => {
    logApi('GET /api/users - pobieranie listy u≈ºytkownik√≥w (chronione).');
    if (req.user.role !== 'superadmin') {
        logAuth('Odmowa dostƒôpu do /api/users dla u≈ºytkownika %s (rola: %s)', req.user.username, req.user.role);
        return res.status(403).json({ message: 'Brak uprawnie≈Ñ.' });
    }
    try {
        const query = 'SELECT id, username, role FROM users ORDER BY id';
        logDb('Wykonywanie zapytania do bazy: %s', query);
        const [users] = await pool.query(query);
        logDb('Pobrano %d u≈ºytkownik√≥w z bazy.', users.length);
        res.status(200).json(users);
    } catch (error) {
        logError('B≈ÇƒÖd przy pobieraniu listy u≈ºytkownik√≥w: %o', error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera.' });
    }
});

// Tworzenie nowego u≈ºytkownika - teraz wymaga tokenu
app.post('/api/users', authenticateToken, async (req, res) => {
    logApi('POST /api/users - tworzenie nowego u≈ºytkownika (chronione).');
    if (req.user.role !== 'superadmin') {
        logAuth('Odmowa dostƒôpu do POST /api/users dla u≈ºytkownika %s (rola: %s)', req.user.username, req.user.role);
        return res.status(403).json({ message: 'Brak uprawnie≈Ñ.' });
    }
    const { username, password } = req.body;
    if (!username || !password) {
        logApi('Tworzenie u≈ºytkownika odrzucone: Brak nazwy u≈ºytkownika lub has≈Ça.');
        return res.status(400).json({ message: 'Nazwa u≈ºytkownika i has≈Ço sƒÖ wymagane.' });
    }
    try {
        const hashedPassword = await bcrypt.hash(password, 10);
        const query = 'INSERT INTO users (username, password_hash, role) VALUES (?, ?, ?)';
        logDb('Wykonywanie zapytania do bazy: %s', query);
        await pool.query(query, [username, hashedPassword, 'admin']);
        logDb('Utworzono nowego u≈ºytkownika: %s', username);
        res.status(201).json({ message: `U≈ºytkownik ${username} zosta≈Ç pomy≈õlnie utworzony.` });
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            logDb('Nie uda≈Ço siƒô utworzyƒá u≈ºytkownika - nazwa %s ju≈º istnieje.', username);
            return res.status(409).json({ message: 'U≈ºytkownik o tej nazwie ju≈º istnieje.' });
        }
        logError('B≈ÇƒÖd przy tworzeniu u≈ºytkownika: %o', error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera.' });
    }
});

// Usuwanie u≈ºytkownika - teraz wymaga tokenu
app.delete('/api/users/:id', authenticateToken, async (req, res) => {
    const userIdToDelete = parseInt(req.params.id, 10);
    logApi('DELETE /api/users/%d - usuwanie u≈ºytkownika (chronione).', userIdToDelete);

    if (req.user.role !== 'superadmin') {
        logAuth('Odmowa dostƒôpu do DELETE /api/users dla u≈ºytkownika %s (rola: %s)', req.user.username, req.user.role);
        return res.status(403).json({ message: 'Brak uprawnie≈Ñ.' });
    }
    if (isNaN(userIdToDelete)) {
        logApi('Usuwanie u≈ºytkownika odrzucone: Nieprawid≈Çowe ID.');
        return res.status(400).json({ message: 'Nieprawid≈Çowe ID u≈ºytkownika.' });
    }
    if (userIdToDelete === req.user.id || userIdToDelete === 1) {
        logAuth('Odmowa usuniƒôcia u≈ºytkownika %d przez %s - pr√≥ba usuniƒôcia samego siebie lub superadmina.', userIdToDelete, req.user.username);
        return res.status(403).json({ message: 'Nie mo≈ºna usunƒÖƒá samego siebie lub g≈Ç√≥wnego superadministratora.' });
    }
    try {
        const query = 'DELETE FROM users WHERE id = ?';
        logDb('Wykonywanie zapytania do bazy: %s', query);
        const [result] = await pool.query(query, [userIdToDelete]);
        if (result.affectedRows === 0) {
            logDb('Nie znaleziono u≈ºytkownika o ID %d do usuniƒôcia.', userIdToDelete);
            return res.status(404).json({ message: 'Nie znaleziono u≈ºytkownika o podanym ID.' });
        }
        logDb('Pomy≈õlnie usuniƒôto u≈ºytkownika o ID %d.', userIdToDelete);
        res.status(200).json({ message: 'U≈ºytkownik zosta≈Ç pomy≈õlnie usuniƒôty.' });
    } catch (error) {
        logError(`B≈ÇƒÖd przy usuwaniu u≈ºytkownika o ID ${userIdToDelete}: %o`, error);
        res.status(500).json({ message: 'WystƒÖpi≈Ç b≈ÇƒÖd serwera.' });
    }
});


// --- URUCHOMIENIE SERWERA ---
const https = require('https');
const fs = require('fs');
const path = require('path');

try {
    logServer('Pr√≥ba wczytania certyfikat√≥w SSL...');
    const key = fs.readFileSync(path.join(__dirname, 'certs', 'key.pem'));
    const cert = fs.readFileSync(path.join(__dirname, 'certs', 'cert.pem'));
    logServer('Certyfikaty SSL wczytane pomy≈õlnie.');

    https.createServer({ key, cert }, app).listen(port, '0.0.0.0', () => {
        logServer(`‚úÖ Serwer API (HTTPS) dzia≈Ça i nas≈Çuchuje na https://0.0.0.0:${port}`);
    });
} catch (err) {
    logError('Nie uda≈Ço siƒô uruchomiƒá serwera HTTPS. Sprawd≈∫, czy pliki certs/key.pem i certs/cert.pem istniejƒÖ. B≈ÇƒÖd: %o', err);
    logServer('Uruchamianie serwera na HTTP jako fallback...');
    app.listen(port, '0.0.0.0', () => {
        logServer(`‚úÖ Serwer API (HTTP - FALLBACK) dzia≈Ça na http://0.0.0.0:${port}`);
    });
}


// --- OBS≈ÅUGA B≈ÅƒòD√ìW ---
process.on('unhandledRejection', (reason, promise) => {
    logError('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    logError('Uncaught Exception thrown:', error);
    process.exit(1);
});